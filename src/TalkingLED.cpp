/* .+

.context    : Arduino Utility Libraries
.title      : Talking LED Library
.kind       : c++ source
.author     : Fabrizio Pollastri <mxgbot@gmail.com>
.site       : Revello - Italy
.creation   : 3-12-2018
.copyright  : (c) 2018 Fabrizio Pollastri

.description

  Make your system to display messages by LED blinking
  With this library, your on board LED can display a lot
  of useful messages. Each message is rendered by an
  on, off sequence with a specific timing.
  Sequences can be user defined or generated by a builtin code.
  Builtin sequences are able to display 15 different
  message codes.

.- */


#include <TalkingLED.h>


TalkingLED::TalkingLED(void) {
  LEDPin = LED_PIN;
  LEDStatus = TLED_OFF;
  digitalWrite(LEDPin,LEDStatus);
  pinMode(LEDPin,OUTPUT);
  messageCode = 0;
  messageCodeCurrent = 0;
  sequence_ = NULL;
  sequenceCurrent = NULL;
  sequenceEnd = false;
  i = 0;
}


boolean TalkingLED::begin() {
  return true;
}


boolean TalkingLED::begin(uint8_t aLEDPin) {
  LEDPin = aLEDPin;
  return true;
}


boolean TalkingLED::message(uint8_t aMessageCode) {
  messageCode = aMessageCode;
  sequence_ = NULL;
  return true;
}


boolean TalkingLED::sequence(uint16_t *aSequence) {
  sequence_ = aSequence;
  messageCode = 0;
  return true;
}


boolean TalkingLED::update(void) {
  now = millis();
  if (sequenceCurrent) {
    if (now < nextChange)
      return false;
    else {
      sequenceEnd = false;
      if (sequenceCurrent[i]) {
        LEDStatus ^= 0x1;
        digitalWrite(LEDPin,LEDStatus);
        nextChange = now + sequenceCurrent[i++];
        return true;
      }
      else
	sequenceEnd = true;
    }
  }
  if (messageCode) {
    if (messageCodeCurrent != messageCode) {
      messageCodeCurrent = messageCode;
      _build_message_sequence(messageCodeCurrent);
    }
    sequence_ = messageSequence;
  }
  sequenceCurrent = sequence_;
  i = 0;
  nextChange = now;
  return false;
}


void TalkingLED::waitEnd() {
  while (!sequenceEnd) {
    update();
    ::delay(TLED_DELAY_STEP);
  }
  sequenceEnd = false;
  sequenceCurrent = NULL;
}


void TalkingLED::delay(uint32_t aDelay) {
  delayEnd = aDelay + millis();
  while (delayEnd - millis() > TLED_DELAY_STEP) {
    update();
    ::delay(TLED_DELAY_STEP);
  }
  update();
  ::delay(delayEnd - millis());
}


void TalkingLED::set(uint8_t aLEDStatus) {
  LEDStatus = aLEDStatus;
  digitalWrite(LEDPin,LEDStatus);
  sequence_ = NULL;
  sequenceCurrent = NULL;
  messageCode = 0;
  messageCodeCurrent = 0;
}


boolean TalkingLED::_build_message_sequence(uint8_t aMessageCode) {
  messageCode = aMessageCode;
  if (messageCode > TLED_MESSAGE_CODE_MAX)
    return false;
  int i = 6;
  for (int j=0; j < messageCode / TLED_LONG_BLINK_UNITS; j++) {
    messageSequence[i++] = TLED_LONG_BLINK_ON_TIME;
    messageSequence[i++] = TLED_LONG_BLINK_OFF_TIME;
  }
  for (j=0; j < messageCode % TLED_LONG_BLINK_UNITS; j++) {
    messageSequence[i++] = TLED_SHORT_BLINK_ON_TIME;
    messageSequence[i++] = TLED_SHORT_BLINK_OFF_TIME;
  }
  messageSequence[i-1] = TLED_MESSAGE_END_OFF_TIME;
  messageSequence[i] = 0;
  return true;
}

/**** END ****/
